
glsl testbench -- a WIP opengl wrapper/shader testing system

requirements: c++14 (maybe? perhaps 11 is enough), Windows (currently), OpenGL 4.5
tested only on msvc with VS17

The goal of this project is to reduce unnecessary friction in rapid prototyping of OpenGL code. This is achieved by treating the shader as the key primitive; essentially all of the interesting operations in rendering happen in a shader, with the host code mostly handling object binding and some simple configuration of the fixed-function parts in the pipeline. The object binding API in OpenGL is unnecessarily complicated; fixing this is the main objective of this project. The pipeline configuration part is relatively painless with plain OpenGL so it's used as is. As a general rule, all of the proposed subsystems can be used in isolation with plain OpenGL; nothing should be overly intrusive.
There are four main categories of helpers in this wrapper: the object binding system (gl_helpers.h), lifetime-handled GL objects (gl_helpers.h), timing helpers (gl_timing.h), and a window/extension handling system (window.h).
The object binding system is rather straight forward, but has the largest impact of all of these. It turns the location-index-bindpoint-mess into a function call that binds any type of OpenGL object with a name and the GLuint of the type. Uniform and shader storage buffers can be bound with bindBuffer and textures with bindTexture -- these just take the glsl name and the object ID. For output textures (for multiple render targets) you can give the MIP level of the texture to draw in (but it's most likely almost always 0 so this is the default argument). Binding images is slightly more complicated as they require access and format information that cannot be deduced from the shader (todo: could this still be done for most cases for better default arguments?). Similar by-name uniform value replacement are introduced for the basic types for the sake of completeness (e.g. glUniform1i can now be called with a string as the first argument). Note that vertex buffers are completely absent; their API is something of a lost cause, and it is quite a bit simpler to read storage buffers based on gl_VertexID than to deal with vertex buffers. (todo: performance measurements. should be equivalent for reasonable hardware, as this is what the driver does anyway)
The lifetime-handled GL objects are somewhat like std::unique_ptr, but for GL-generated GLuint-based objects instead of pointers. The idea is to leverage RAII to avoid having to remember to delete all of the objects, and to avoid the clumsy C-esque API for creating objects. To be precise, these do NOT handle creation of the memory as there are many ways you might want to do that and they aren't as painful; these simply create and destroy the GL object itself. Currently you can load image files into 2D textures with loadImage, other helpers (like constructing Buffers from std::vector) require a bit of a refactor but will come in time.
The timing helper is essentially a single class, TimeStamp. It queries both CPU and GPU times at construct time, so you just scatter these around your code and at some point (end of the frame is a good place) query the differences: either the GPU timing difference between the stamps (this is done directly via substraction or with gpuTime(begin, end)), or TimeStamp::latency that gives you the difference between when the CPU and GPU execution got to a stamp, or driverTime(begin,end) that gives you the time the CPU spent on issuing the draw calls. The last two are good for measuring driver overhead -- the project mostly embraces the AZRDO (Approaching Zero Regard for Driver Overhead) philosophy, so for some use cases you might want to keep an eye on that.
Finally, the extension handling and windowing code is mostly what happened to be at hand; you can quite freely replace it with any other alternative. The main issue with this is that it's Windows-only, and that it requires some work to change OpenGL versions (4.6 is provided). The uniform name overloading requires from the extension system that OpenGL extension function names aren't directly used for pointers, but are overloadable functions that indirect the calls. (todo: look into other extension handlers, do they do this?)

As general other things included in the repo, there's a text rendering system (that requires some clean-up and potential cross-platform support), a shader printf implementation (https://github.com/msqrt/shader-printf) and some math helpers. These are there just to smooth things out and will likely slowly change.

The system is not publicly released yet, and thus the asset folder contains objects that are almost certainly copyrighted.